---
import Card from "./Card.astro";

const { tabData, booleanFields } = Astro.props;

// Flatten all entries across tabs, excluding Databases
const allEntries = Object.entries(tabData)
  .filter(([tab]) => tab !== "Databases")
  .flatMap(([tab, payload]) =>
    payload.rows
      ? payload.rows.map((row) => ({
          ...row,
          tab,
          id: `${tab}-${row.Title || row.title}`,
        }))
      : []
  );

// Color map for affordances
const colorMap = {
  Materiality: "#FF6B6B",
  Ownability: "#4ECDC4",
  Updatability: "#45B7D1",
  Interactivity: "#FFA07A",
  Searchability: "#98D8C8",
  Traceability: "#F7DC6F",
};
---

<div class="network-view" style="display: none;">
  <button class="view-toggle network-toggle" id="networkToggle">
    <span class="toggle-text">Grid View</span>
  </button>
  <svg class="network-canvas"></svg>
  <div class="network-container">
    {
      allEntries.map((entry) => {
        const tags = booleanFields.filter((field) => {
          const val = entry[field];
          return val && String(val).trim().toUpperCase() === "TRUE";
        });
        return (
          <div
            class="network-card"
            data-node-id={entry.id}
            data-tags={tags.join(",")}
            data-type="entry"
          >
            <Card row={entry} booleanFields={booleanFields} tab={entry.tab} />
          </div>
        );
      })
    }
    {
      booleanFields.map((field) => (
        <div
          class="affordance-node"
          data-node-id={`affordance-${field}`}
          data-type="affordance"
        >
          <div class="affordance-label">{field}</div>
        </div>
      ))
    }
  </div>
</div>

<script>
  import * as d3 from "d3";

  document.addEventListener("DOMContentLoaded", () => {
    const canvas = document.querySelector(".network-canvas") as SVGSVGElement;
    const container = document.querySelector(
      ".network-container"
    ) as HTMLElement;

    if (!canvas || !container) return;

    // Color palette for affordances
    const colorMap = new Map([
      ["Materiality", "#FF6B6B"],
      ["Ownability", "#4ECDC4"],
      ["Updatability", "#45B7D1"],
      ["Interactivity", "#FFA07A"],
      ["Searchability", "#98D8C8"],
      ["Traceability", "#F7DC6F"],
    ]);

    let simulation: d3.Simulation<any, any> | null = null;
    let svg: d3.Selection<SVGSVGElement, unknown, null, undefined>;

    function initializeNetwork() {
      const networkView = document.querySelector(
        ".network-view"
      ) as HTMLElement;
      if (!networkView || networkView.style.display === "none") return;

      const width = window.innerWidth;
      const height = window.innerHeight;

      // Clear previous
      canvas.innerHTML = "";
      svg = d3.select(canvas).attr("width", width).attr("height", height);

      // Add zoom/pan group
      const defs = svg.append("defs");

      // Add zoom/pan behavior
      const g = svg.append("g");
      const zoom = d3
        .zoom()
        .scaleExtent([0.3, 2])
        .extent([
          [0, 0],
          [width, height],
        ])
        .translateExtent([
          [-width * 3, -height * 3],
          [width * 4, height * 4],
        ])
        .duration(300)
        .on("zoom", (event) => {
          const transform = event.transform;
          // Apply to SVG group (lines)
          g.attr("transform", transform);
          // Apply to HTML container (cards and affordances)
          container.style.transform = `translate(${transform.x}px, ${transform.y}px) scale(${transform.k})`;
          container.style.transformOrigin = "0 0";
          container.style.transition =
            "transform 0.15s cubic-bezier(0.4, 0, 0.2, 1)";
        });

      // Apply zoom only to empty areas, not on nodes
      svg.call(zoom as any);

      // Set initial zoom to 0.6 centered on the viewport
      const initialTransform = d3.zoomIdentity
        .translate(width / 2, height / 2)
        .scale(0.6)
        .translate(-width / 2, -height / 2);
      svg.call(zoom.transform as any, initialTransform);

      // Prevent zoom/pan when interacting with cards and affordances
      d3.selectAll(".network-card, .affordance-node").on(
        "mousedown.zoom",
        (event) => {
          event.stopPropagation();
        }
      );

      // Get all node elements
      const cardNodes = Array.from(
        document.querySelectorAll(".network-card")
      ) as HTMLElement[];
      const affordanceNodes = Array.from(
        document.querySelectorAll(".affordance-node")
      ) as HTMLElement[];
      const allNodeElements = [...cardNodes, ...affordanceNodes];

      // Create data for simulation with dynamic radius
      const nodes = allNodeElements.map((el) => {
        const width = el.offsetWidth;
        const height = el.offsetHeight;
        const radius = Math.max(width, height) / 2 + 20;
        return {
          id: el.getAttribute("data-node-id")!,
          element: el,
          type: el.getAttribute("data-type")!,
          radius: radius,
          tags:
            el
              .getAttribute("data-tags")
              ?.split(",")
              .filter((t) => t) || [],
        };
      });

      // Line style map for each affordance
      const lineStyles = new Map([
        ["Materiality", "4,2"],
        ["Ownability", "8,4"],
        ["Updatability", "1,3"],
        ["Interactivity", "12,4,2,4"],
        ["Searchability", "8,2,2,2"],
        ["Traceability", "none"],
      ]);

      // Create links (reversed: affordance -> entry)
      const links: any[] = [];
      nodes
        .filter((n) => n.type === "entry")
        .forEach((entry) => {
          entry.tags.forEach((tag: string) => {
            links.push({
              source: `affordance-${tag}`,
              target: entry.id,
              affordance: tag,
            });
          });
        });

      // Draw links in SVG FIRST (so they're below)
      const linkElements = g
        .append("g")
        .selectAll("line")
        .data(links)
        .join("line")
        .attr("stroke", "#000")
        .attr("stroke-opacity", 0.05)
        .attr("stroke-width", 5)
        .attr(
          "stroke-dasharray",
          (d: any) => lineStyles.get(d.affordance) || "none"
        )
        .attr("class", "network-link")
        .attr("data-affordance", (d: any) => d.affordance);

      // Draw center circle (hollow)
      const centerCircle = g
        .append("circle")
        .attr("cx", width / 2)
        .attr("cy", height / 2)
        .attr("r", Math.min(width, height) * 0.35)
        .attr("fill", "none")
        .attr("stroke", "#000")
        .attr("stroke-width", 5)
        .attr("stroke-opacity", 1.0);

      // Position affordances in a circle
      const affordanceDataNodes = nodes.filter(
        (n: any) => n.type === "affordance"
      );
      const entryNodes = nodes.filter((n: any) => n.type === "entry");
      const circleRadius = Math.min(width, height) * 0.35;
      affordanceDataNodes.forEach((node: any, i: number) => {
        const angle = (i / affordanceDataNodes.length) * 2 * Math.PI;
        node.fx = width / 2 + circleRadius * Math.cos(angle);
        node.fy = height / 2 + circleRadius * Math.sin(angle);
      });

      // Draw lines from center to each affordance
      const centerLines = g
        .append("g")
        .selectAll("line")
        .data(affordanceDataNodes)
        .join("line")
        .attr("x1", width / 2)
        .attr("y1", height / 2)
        .attr("x2", (d: any) => d.fx)
        .attr("y2", (d: any) => d.fy)
        .attr("stroke", "#000")
        .attr("stroke-width", 5)
        .attr("stroke-opacity", 1.0)
        .attr("class", "center-line");

      // Radial force to keep entries outside the affordance circle
      const radialForce = (alpha: number) => {
        entryNodes.forEach((node: any) => {
          const dx = node.x - width / 2;
          const dy = node.y - height / 2;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const minDistance = circleRadius + 150; // Keep entries at least 150px outside circle

          if (distance < minDistance) {
            const angle = Math.atan2(dy, dx);
            const force = (minDistance - distance) * alpha * 2;
            node.vx += Math.cos(angle) * force;
            node.vy += Math.sin(angle) * force;
          }
        });
      };

      // Create simulation with dynamic collision radius
      simulation = d3
        .forceSimulation(nodes)
        .force(
          "link",
          d3
            .forceLink(links)
            .id((d: any) => d.id)
            .distance(600)
            .strength(0.05)
        )
        .force(
          "charge",
          d3
            .forceManyBody()
            .strength((d: any) => (d.type === "affordance" ? 0 : -1000))
        )
        .force("center", d3.forceCenter(width / 2, height / 2))
        .force(
          "collision",
          d3.forceCollide().radius((d: any) => d.radius * 1.5)
        )
        .force("radial", radialForce);

      // Position HTML nodes on tick
      simulation.on("tick", () => {
        nodes.forEach((d: any) => {
          if (d.type === "affordance") {
            d.element.style.left = `${d.x}px`;
            d.element.style.top = `${d.y}px`;
          } else {
            d.element.style.left = `${d.x - d.element.offsetWidth / 2}px`;
            d.element.style.top = `${d.y - d.element.offsetHeight / 2}px`;
          }
        });

        linkElements
          .attr("x1", (d: any) => d.source.x)
          .attr("y1", (d: any) => d.source.y)
          .attr("x2", (d: any) => {
            const target = d.target;
            const cardWidth = target.element.offsetWidth;
            const cardHeight = target.element.offsetHeight;

            // Calculate 4 side midpoints
            const left = { x: target.x - cardWidth / 2, y: target.y };
            const right = { x: target.x + cardWidth / 2, y: target.y };
            const top = { x: target.x, y: target.y - cardHeight / 2 };
            const bottom = { x: target.x, y: target.y + cardHeight / 2 };

            // Find closest side to source
            const sides = [left, right, top, bottom];
            let closest = sides[0];
            let minDist = Math.hypot(
              d.source.x - closest.x,
              d.source.y - closest.y
            );

            for (const side of sides) {
              const dist = Math.hypot(d.source.x - side.x, d.source.y - side.y);
              if (dist < minDist) {
                minDist = dist;
                closest = side;
              }
            }

            return closest.x;
          })
          .attr("y2", (d: any) => {
            const target = d.target;
            const cardWidth = target.element.offsetWidth;
            const cardHeight = target.element.offsetHeight;

            // Calculate 4 side midpoints
            const left = { x: target.x - cardWidth / 2, y: target.y };
            const right = { x: target.x + cardWidth / 2, y: target.y };
            const top = { x: target.x, y: target.y - cardHeight / 2 };
            const bottom = { x: target.x, y: target.y + cardHeight / 2 };

            // Find closest side to source
            const sides = [left, right, top, bottom];
            let closest = sides[0];
            let minDist = Math.hypot(
              d.source.x - closest.x,
              d.source.y - closest.y
            );

            for (const side of sides) {
              const dist = Math.hypot(d.source.x - side.x, d.source.y - side.y);
              if (dist < minDist) {
                minDist = dist;
                closest = side;
              }
            }

            return closest.y;
          });
      });

      // Drag behavior
      const drag = d3
        .drag<any, any>()
        .on("start", (event, d) => {
          if (!event.active) simulation?.alphaTarget(0.3).restart();
          d.fx = d.x;
          d.fy = d.y;
        })
        .on("drag", (event, d) => {
          d.fx = event.x;
          d.fy = event.y;
        })
        .on("end", (event, d) => {
          if (!event.active) simulation?.alphaTarget(0);
          d.fx = null;
          d.fy = null;
        });

      // Apply drag to all elements (cards and affordances)
      nodes.forEach((node: any) => {
        const element = d3.select(node.element);
        element.call(drag as any);
        // Ensure drag cursor works
        node.element.style.cursor = "grab";
        node.element.addEventListener("mousedown", () => {
          node.element.style.cursor = "grabbing";
        });
        node.element.addEventListener("mouseup", () => {
          node.element.style.cursor = "grab";
        });
      });

      // Add hover effects for cards
      nodes
        .filter((n) => n.type === "entry")
        .forEach((node: any) => {
          node.element.addEventListener("mouseenter", () => {
            // Fade other cards and highlight related affordances
            const relatedAffordances = new Set<string>();
            nodes.forEach((n: any) => {
              if (n.type === "entry" && n.id !== node.id) {
                n.element.classList.add("faded");
              } else if (n.type === "entry" && n.id === node.id) {
                // Collect affordances for this card
                n.tags.forEach((tag: string) => {
                  relatedAffordances.add(`affordance-${tag}`);
                });
              }
            });

            // Highlight related affordances
            nodes.forEach((n: any) => {
              if (n.type === "affordance") {
                if (relatedAffordances.has(n.id)) {
                  n.element.classList.add("highlighted");
                }
              }
            });

            // Hide center lines only
            centerLines.attr("stroke-opacity", 0);

            // Highlight related links
            linkElements.each(function (d: any) {
              const link = d3.select(this);
              if (d.target.id === node.id) {
                link.attr("stroke-width", 4).attr("stroke-opacity", 0.8);
              } else {
                link.attr("stroke-opacity", 0.05);
              }
            });
          });

          node.element.addEventListener("mouseleave", () => {
            // Remove fade and highlight from all
            nodes.forEach((n: any) => {
              n.element.classList.remove("faded", "highlighted");
            });

            // Show center lines
            centerLines.attr("stroke-opacity", 1.0);

            // Reset all links
            linkElements.attr("stroke-width", 5).attr("stroke-opacity", 0.05);
          });
        });

      // Add hover effects for affordances
      nodes
        .filter((n) => n.type === "affordance")
        .forEach((node: any) => {
          const affordanceName = node.id.replace("affordance-", "");

          node.element.addEventListener("mouseenter", () => {
            // Highlight this affordance
            node.element.classList.add("highlighted");

            // Fade unrelated cards
            nodes.forEach((n: any) => {
              if (n.type === "entry") {
                const hasTag = n.tags.includes(affordanceName);
                if (!hasTag) {
                  n.element.classList.add("faded");
                }
              } else if (n.type === "affordance" && n.id !== node.id) {
                n.element.classList.add("faded");
              }
            });

            // Fade unrelated links
            linkElements.each(function (d: any) {
              const link = d3.select(this);
              if (d.affordance === affordanceName) {
                link.attr("stroke-width", 4).attr("stroke-opacity", 0.8);
              } else {
                link.attr("stroke-opacity", 0.02);
              }
            });
          });

          node.element.addEventListener("mouseleave", () => {
            // Remove fade and highlight from all
            nodes.forEach((n: any) => {
              n.element.classList.remove("faded", "highlighted");
            });

            // Reset all links
            linkElements.attr("stroke-width", 5).attr("stroke-opacity", 0.05);
          });
        });
    }

    // Initialize on mode switch
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (
          mutation.type === "attributes" &&
          mutation.attributeName === "style"
        ) {
          const target = mutation.target as HTMLElement;
          if (
            target.classList.contains("network-view") &&
            target.style.display !== "none"
          ) {
            setTimeout(() => {
              initializeNetwork();
            }, 100);
          } else if (
            target.classList.contains("network-view") &&
            target.style.display === "none"
          ) {
            if (simulation) {
              simulation.stop();
            }
          }
        }
      });
    });

    const networkView = document.querySelector(".network-view");
    if (networkView) {
      observer.observe(networkView, { attributes: true });
    }

    // Redraw on window resize
    window.addEventListener("resize", () => {
      if (
        networkView &&
        (networkView as HTMLElement).style.display !== "none"
      ) {
        initializeNetwork();
      }
    });
  });
</script>
